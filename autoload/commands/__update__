#!/usr/bin/env zsh
# Description:
#   Update installed packages in parallel

local     is_force=false
local     repo arg filter
local -A  repo_pids proc_states hook_build hook_finished hook_pids status_codes repo_dir
local -A  tags
local -F  SECONDS=0
local -aU repos
local -i  queue_max=$ZPLUG_THREADS
local -i  spinner_idx subspinner_idx status_code=0
local -i  timeout=60

while (( $# > 0 ))
do
    arg="$1"
    case "$arg" in
        --select)
            zstyle ':zplug:core:update' 'select' yes
            ;;
        --force)
            is_force=true
            ;;
        -*|--*)
            __zplug::core::options::unknown "$arg"
            return $status
            ;;
        "")
            # Invalid
            return 1
            ;;
        */*)
            repos+=( "${arg:gs:@::}" )
            ;;
        *)
            return 1
            ;;
    esac
    shift
done

if ! __zplug::core::share::init_parallel --update "$repos[@]"; then
    # Since the initialization has failed, this command is terminated.
    # The error message etc. should be done within that function.
    return 1
fi
repos=( "$reply[@]" )

for repo in "$repos[@]"
do
    # Run installation in subprocess
    __zplug::core::tags::parse "$repo"
    tags=( "${reply[@]}" )

    {
        if [[ -d $tags[dir] ]]; then
            if (( $_zplug_boolean_true[(I)$tags[frozen]] )); then
                status_code=$_zplug_status[update_skip_frozen]
            else
                if __zplug::core::sources::is_handler_defined "update" "$tags[from]"; then
                    __zplug::core::sources::use_handler \
                        "update" \
                        "$tags[from]" \
                        "$repo"
                    status_code=$status
                else
                    status_code=$_zplug_status[update_local_repo]
                fi
            fi
        else
            status_code=$_zplug_status[update_repo_not_found]
        fi

        # Manage the status codes in a file
        # to lock the file in order to write asynchronously
        __zplug::job::handle::flock \
            "$_zplug_config[update_status]" \
            "repo:$repo\tstatus:$status_code"
    } &

    repo_pids[$repo]=$!
    repo_dir[$repo]="$tags[dir]"
    hook_build[$repo]="$tags[hook-build]"
    hook_finished[$repo]=false
    proc_states[$repo]="created"
    status_codes[$repo]=""

    if ( (( $#repos >= $queue_max )) && (( $#repo_pids >= $queue_max )) ) ||
        ( (( $#repos >= $queue_max )) && (( $#status_codes == $#repos )) ) ||
        ( (( $#repos < $queue_max )) && (( $#repo_pids == $#repos )) ); then
        repeat $(($#repo_pids + 2)); do printf "\n"; done
        #
        # Multiple progress bars
        #
        # Use printf command (not builtin) instead of __zplug::io::print::f function,
        # because this loop is run the processing by interval of 0.1 second
        # and there is a need to be called faster
        while __zplug::job::state::running "$repo_pids[@]" "$hook_pids[@]" || (( ${(k)#proc_states[(R)running]} > 0 ))
        do
            sleep 0.1
            __zplug::utils::ansi::cursor_up $(($#repo_pids + 2)) #$(($#repos + 2))

            # Count up within _zplug_spinners index
            if (( ( spinner_idx+=1 ) > $#_zplug_spinners )); then
                spinner_idx=1
            fi
            # Count up within _zplug_sub__zplug_spinners index
            if (( ( subspinner_idx+=1 ) > $#_zplug_sub__zplug_spinners )); then
                subspinner_idx=1
            fi

            # Processing pids
            for repo in "${(k)repo_pids[@]}"
            do
                if __zplug::job::state::running "$repo_pids[$repo]"; then
                    __zplug::job::message::updating \
                        $_zplug_spinners[$spinner_idx] \
                        "$repo"
                    proc_states[$repo]="running"
                else
                    # If $repo has build-hook tag
                    if [[ -n $hook_build[$repo] ]]; then
                        # Save status code for process cache
                        if [[ -z $status_codes[$repo] ]]; then
                            status_codes[$repo]="$(__zplug::job::state::get "$repo" update)"
                        fi
                        if [[ $status_codes[$repo] != 0 ]]; then
                            #__zplug::job::message::failed_to_update_with_hook "$repo"
                            case $status_codes[$repo] in
                                $_zplug_status[update_success])
                                    __zplug::job::message::updated "$repo"
                                    ;;
                                $_zplug_status[update_failure])
                                    __zplug::job::message::failed_to_update "$repo"
                                    ;;
                                $_zplug_status[update_skip_if])
                                    __zplug::job::message::skipped_due_to_if_tag "$repo"
                                    ;;
                                $_zplug_status[update_up_to_date])
                                    __zplug::job::message::up_to_date "$repo"
                                    ;;
                                $_zplug_status[update_skip_frozen])
                                    __zplug::job::message::skipped_due_to_frozen_tag "$repo"
                                    ;;
                                $_zplug_status[update_local_repo])
                                    __zplug::job::message::local_repo "$repo"
                                    ;;
                                $_zplug_status[update_repo_not_found])
                                    __zplug::job::message::repo_not_found "$repo"
                                    ;;
                                *)
                                    __zplug::job::message::unknown "$repo"
                                    ;;
                            esac
                            proc_states[$repo]="terminated"
                            continue
                        fi

                        if ! $hook_finished[$repo]; then
                            hook_finished[$repo]=true
                            # Run the hook-build in background
                            {
                                __zplug::job::hook::build "$repo"
                                if (( $status > 0 )); then
                                    printf "$repo\n" >>|"$_zplug_config[build_failure]"
                                    printf "$repo\n" >>|"$_zplug_config[build_rollback]"
                                else
                                    printf "$repo\n" >>|"$_zplug_config[build_success]"
                                fi
                            } & hook_pids[$repo]=$!
                            # Run the timeout process in background
                            {
                                # kill the process for hook-build after sleeping
                                # during the number of seconds that has been set as a timeout
                                sleep "$timeout"

                                # Check if $repo_pids don't run
                                # and check if the process ($hook_pids[$repo]) that has should be killed
                                if __zplug::job::state::running $hook_pids[$repo] && ! __zplug::job::state::running "$repo_pids[@]"; then
                                    __zplug::job::state::kill $hook_pids[$repo]
                                    printf "$repo\n" >>|"$_zplug_config[build_timeout]"
                                    printf "$repo\n" >>|"$_zplug_config[build_rollback]"
                                fi
                            } &
                        fi

                        if __zplug::job::state::running "$hook_pids[$repo]"; then
                            # running build-hook
                            __zplug::utils::ansi::erace_current_line
                            __zplug::job::message::updated_with_hook_spinning \
                                "$_zplug_spinners[$spinner_idx]" \
                                "$repo" \
                                "$_zplug_sub__zplug_spinners[$subspinner_idx]"
                        else
                            # finished build-hook
                            __zplug::utils::ansi::erace_current_line
                            if __zplug::job::hook::build_failure "$repo"; then
                                __zplug::job::message::updated_with_hook_failure "$repo"
                            elif __zplug::job::hook::build_timeout "$repo"; then
                                __zplug::job::message::updated_with_hook_timeout "$repo"
                            else
                                __zplug::job::message::updated_with_hook_success "$repo"
                            fi
                        fi
                    else
                        # Save status code for process cache
                        if [[ -z $status_codes[$repo] ]]; then
                            status_codes[$repo]="$(__zplug::job::state::get "$repo" update)"
                        fi
                        case $status_codes[$repo] in
                            $_zplug_status[update_success])
                                __zplug::job::message::updated "$repo"
                                ;;
                            $_zplug_status[update_failure])
                                __zplug::job::message::failed_to_update "$repo"
                                ;;
                            $_zplug_status[update_skip_if])
                                __zplug::job::message::skipped_due_to_if_tag "$repo"
                                ;;
                            $_zplug_status[update_up_to_date])
                                __zplug::job::message::up_to_date "$repo"
                                ;;
                            $_zplug_status[update_skip_frozen])
                                __zplug::job::message::skipped_due_to_frozen_tag "$repo"
                                ;;
                            $_zplug_status[update_local_repo])
                                __zplug::job::message::local_repo "$repo"
                                ;;
                            $_zplug_status[update_repo_not_found])
                                __zplug::job::message::repo_not_found "$repo"
                                ;;
                            *)
                                __zplug::job::message::unknown "$repo"
                                ;;
                        esac
                    fi
                    proc_states[$repo]="terminated"
                fi
            done

            if __zplug::job::state::running "$repo_pids[@]" "$hook_pids[@]"; then
                printf "\n"
                __zplug::io::print::f \
                    --zplug \
                    "Finished: %d/%d plugins\n" \
                    ${(k)#proc_states[(R)terminated]} \
                    $#repos
            else
                repo_pids=()
            fi
        done
    fi
done

tput cnorm
printf "\n"
__zplug::utils::ansi::erace_current_line
__zplug::io::print::f \
    --zplug \
    "Elapsed time: %.4f sec.\n" \
    $SECONDS

if (( ${(k)#status_codes[(R)1]} == 0 )); then
    printf "$fg_bold[default] ==> Updating finished successfully!$reset_color\n"
else
    printf "$fg_bold[red] ==> Updating failed for following packages:$reset_color\n"
    # Listing the packages that have failed to update
    for repo in "${(k)status_codes[@]}"
    do
        if [[ $status_codes[$repo] == 1 ]]; then
            printf " - %s\n" "$repo"
        fi
    done
fi

# Run rollback if hook-build failed
__zplug::job::rollback::message
