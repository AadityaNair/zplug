#!/usr/bin/env zsh
# Description:
#   Update installed packages in parallel

local     repo arg f_pkg c_pkg filter
local -aU repos
local -A  tags
local -a  failed_packages
local -A  checked_packages
local -i  max=0 ret=0
local -F  SECONDS=0 start_time finish_time
local     is_select=false is_force=false

# All variables are treated as local variable
# because of background job (subprocess)
#local    key

local -aU repos
local -A  tags
local -i  status_code=0 cant_lock=0

local -A repo_pids states hook_build hook_finished hook_pids status_codes repo_dir
local -F SECONDS=0
local -a spinners sub_spinners
local -i spinner_idx subspinner_idx
local -i timeout=60
local    is_parallel=""

spinners=(⠋ ⠙ ⠹ ⠸ ⠼ ⠴ ⠦ ⠧ ⠇ ⠏)
sub_spinners=(⠁ ⠁ ⠉ ⠙ ⠚ ⠒ ⠂ ⠂ ⠒ ⠲ ⠴ ⠤ ⠄ ⠄ ⠤ ⠠ ⠠ ⠤ ⠦ ⠖ ⠒ ⠐ ⠐ ⠒ ⠓ ⠋ ⠉ ⠈ ⠈)


while (( $# > 0 ))
do
    arg="$1"
    case "$arg" in
        --select)
            is_select=true
            ;;
        --force)
            is_force=true
            ;;
        -*|--*)
            __zplug::core::options::unknown "$arg"
            return $status
            ;;
        "")
            # Invalid
            return 1
            ;;
        */*)
            repos+=( "${arg:gs:@::}" )
            ;;
        *)
            return 1
            ;;
    esac
    shift
done

# Initialize
{
    if $is_select; then
        __zplug::utils::shell::search_commands \
            "$ZPLUG_FILTER" \
            | read filter
        if [[ -z $filter ]]; then
            __zplug::io::print::f \
                --die \
                --zplug \
                --error \
                --func \
                "There is no available filter in ZPLUG_FILTER\n"
            return 1
        fi
        repos=( ${(@f)"$(echo "${(Fk)zplugs[@]}" | eval "$filter")"} )

        # Cace of type Ctrl-C
        if (( $#repos == 0 )); then
            return 0
        fi
    fi

    if (( $#repos == 0 )); then
        repos=( "${(k)zplugs[@]:gs:@::}" )
    fi

    # Check the number of arguments
    if (( $#repos > 1 )); then
        is_parallel=true
    fi

    rm -f \
        "$_zplug_config[build_success]" \
        "$_zplug_config[build_failure]" \
        "$_zplug_config[build_timeout]" \
        "$_zplug_config[update_status]"
    touch "$_zplug_config[update_status]"
}

# Suppress outputs
setopt nonotify nomonitor
tput civis

for repo in "$repos[@]"
do
    if ! __zplug::base::base::zpluged "$repo"; then
        __zplug::job::spinner::unlock
        __zplug::io::print::f \
            --die \
            --zplug \
            --func \
            "$repo: no such package\n"
        return 1
    fi

    # Run installation in subprocess
    __zplug::core::tags::parse "$repo"
    tags=( "${reply[@]}" )

    {
        if [[ -d $tags[dir] ]]; then
        if (( $_zplug_boolean_true[(I)$tags[frozen]] )); then
            status_code=$_zplug_status[update_skip_frozen]
        else
            if __zplug::core::sources::is_handler_defined "update" "$tags[from]"; then
                __zplug::core::sources::use_handler \
                    "update" \
                    "$tags[from]" \
                    "$repo"
                status_code=$status
            else
                status_code=$_zplug_status[update_local_repo]
            fi
        fi
        else
            status_code=$_zplug_status[update_repo_not_found]
        fi

        # Manage the status codes in a file
        # to lock the file in order to write asynchronously
        __zplug::job::state::flock \
            "$_zplug_config[update_status]" \
            "repo:$repo\tstatus:$status_code"
    } &

    repo_pids[$repo]=$!
    repo_dir[$repo]="$tags[dir]"
    hook_build[$repo]="$tags[hook-build]"
    hook_finished[$repo]=false
    states[$repo]="unfinished"
    status_codes[$repo]=""
done

__zplug::io::print::f \
    --zplug \
    "Start to update %d plugin${is_parallel:+"s"} %s\n\n" \
    $#repos \
    "${is_parallel:+"in parallel"}"

repeat $(($#repos + 2))
do
    printf "\n"
done

#
# Multiple progress bars
#
# Use printf command (not builtin) instead of __zplug::io::print::f function,
# because this loop is run the processing by interval of 0.1 second
# and there is a need to be called faster
while __zplug::job::state::running "$repo_pids[@]" "$hook_pids[@]" || (( ${(k)#states[(R)updating]} > 0 ))
do
    sleep 0.1
    __zplug::utils::ansi::cursor_up $(($#repos + 2))

    # Count up within spinners index
    if (( ( spinner_idx+=1 ) > $#spinners )); then
        spinner_idx=1
    fi
    # Count up within sub_spinners index
    if (( ( subspinner_idx+=1 ) > $#sub_spinners )); then
        subspinner_idx=1
    fi

    # Processing pids
    for repo in "${(k)repo_pids[@]}"
    do
        if __zplug::job::state::running "$repo_pids[$repo]"; then
            __zplug::job::message::updating \
                $spinners[$spinner_idx] \
                "$repo"
            states[$repo]="updating"
        else
            # If $repo has build-hook tag
            if [[ -n $hook_build[$repo] ]]; then
                # Save status code for process cache
                if [[ -z $status_codes[$repo] ]]; then
                    status_codes[$repo]="$(__zplug::job::state::get "$repo" update)"
                fi
                if [[ $status_codes[$repo] != 0 ]]; then
                    #__zplug::job::message::failed_to_update_with_hook "$repo"
                    case $status_codes[$repo] in
                        $_zplug_status[update_success])
                            __zplug::job::message::updated "$repo"
                            ;;
                        $_zplug_status[update_failure])
                            __zplug::job::message::failed_to_update "$repo"
                            ;;
                        $_zplug_status[update_skip_if])
                            __zplug::job::message::skipped_due_to_if_tag "$repo"
                            ;;
                        $_zplug_status[update_up_to_date])
                            __zplug::job::message::up_to_date "$repo"
                            ;;
                        $_zplug_status[update_skip_frozen])
                            __zplug::job::message::skipped_due_to_frozen_tag "$repo"
                            ;;
                        $_zplug_status[update_local_repo])
                            __zplug::job::message::local_repo "$repo"
                            ;;
                        $_zplug_status[update_repo_not_found])
                            __zplug::job::message::repo_not_found "$repo"
                            ;;
                        *)
                            __zplug::job::message::unknown "$repo"
                            ;;
                    esac
                    states[$repo]="finished"
                    continue
                fi

                if ! $hook_finished[$repo]; then
                    hook_finished[$repo]=true
                    # Run the hook-build in background
                    {
                        __zplug::job::hook::build "$repo"
                        if (( $status > 0 )); then
                            printf "$repo\n" >>|"$_zplug_config[build_failure]"
                            printf "$repo\n" >>|"$_zplug_config[build_rollback]"
                        else
                            printf "$repo\n" >>|"$_zplug_config[build_success]"
                        fi
                    } & hook_pids[$repo]=$!
                    # Run the timeout process in background
                    {
                        # kill the process for hook-build after sleeping
                        # during the number of seconds that has been set as a timeout
                        sleep "$timeout"

                        # Check if $repo_pids don't run
                        # and check if the process ($hook_pids[$repo]) that has should be killed
                        if __zplug::job::state::running $hook_pids[$repo] && ! __zplug::job::state::running "$repo_pids[@]"; then
                            __zplug::job::state::kill $hook_pids[$repo]
                            printf "$repo\n" >>|"$_zplug_config[build_timeout]"
                            printf "$repo\n" >>|"$_zplug_config[build_rollback]"
                        fi
                    } &
                fi

                if __zplug::job::state::running "$hook_pids[$repo]"; then
                    # running build-hook
                    __zplug::utils::ansi::erace_current_line
                    __zplug::job::message::updated_with_hook_spinning \
                        "$spinners[$spinner_idx]" \
                        "$repo" \
                        "$sub_spinners[$subspinner_idx]"
                else
                    # finished build-hook
                    __zplug::utils::ansi::erace_current_line
                    if __zplug::job::hook::build_failure "$repo"; then
                        __zplug::job::message::updated_with_hook_failure "$repo"
                    elif __zplug::job::hook::build_timeout "$repo"; then
                        __zplug::job::message::updated_with_hook_timeout "$repo"
                    else
                        __zplug::job::message::updated_with_hook_success "$repo"
                    fi
                fi
            else
                # Save status code for process cache
                if [[ -z $status_codes[$repo] ]]; then
                    status_codes[$repo]="$(__zplug::job::state::get "$repo" update)"
                fi
                case $status_codes[$repo] in
                    $_zplug_status[update_success])
                        __zplug::job::message::updated "$repo"
                        ;;
                    $_zplug_status[update_failure])
                        __zplug::job::message::failed_to_update "$repo"
                        ;;
                    $_zplug_status[update_skip_if])
                        __zplug::job::message::skipped_due_to_if_tag "$repo"
                        ;;
                    $_zplug_status[update_up_to_date])
                        __zplug::job::message::up_to_date "$repo"
                        ;;
                    $_zplug_status[update_skip_frozen])
                        __zplug::job::message::skipped_due_to_frozen_tag "$repo"
                        ;;
                    $_zplug_status[update_local_repo])
                        __zplug::job::message::local_repo "$repo"
                        ;;
                    $_zplug_status[update_repo_not_found])
                        __zplug::job::message::repo_not_found "$repo"
                        ;;
                    *)
                        __zplug::job::message::unknown "$repo"
                        ;;
                esac
            fi
            states[$repo]="finished"
        fi
    done

    printf "\n"
    if __zplug::job::state::running "$repo_pids[@]" "$hook_pids[@]"; then
        __zplug::io::print::f \
            --zplug \
            "Finished: %d/%d plugin%s\n" \
            ${(k)#states[(R)finished]} \
            $#states \
            ${is_parallel:+"s"}
    else
        __zplug::utils::ansi::erace_current_line
        __zplug::io::print::f \
            --zplug \
            "Elapsed time: %.4f sec.\n" \
            $SECONDS
    fi
done

tput cnorm

if (( ${(k)#status_codes[(R)1]} == 0 )); then
    printf "$fg_bold[default] ==> Updating finished successfully!$reset_color\n"
else
    printf "$fg_bold[red] ==> Updating failed for following packages:$reset_color\n"
    # Listing the packages that have failed to update
    for repo in "${(k)status_codes[@]}"
    do
        if [[ $status_codes[$repo] == 1 ]]; then
            printf " - %s\n" "$repo"
        fi
    done
fi

# Run rollback if hook-build failed
if [[ -s $_zplug_config[build_rollback] ]]; then
    if [[ -f $_zplug_config[build_failure] ]] || [[ -f $_zplug_config[build_timeout] ]]; then
        __zplug::io::print::f \
            --zplug \
            "\n$fg_bold[red]These hook-build were failed to run:$reset_color\n"
        # Listing the packages that have failed to build
        {
            sed 's/^/ - /g' "$_zplug_config[build_failure]"
            sed 's/^/ - /g' "$_zplug_config[build_timeout]"
        } 2>/dev/null
        __zplug::io::print::f \
            --zplug \
            "To retry these hook-build, please run '$fg_bold[default]%s$reset_color'.\n" \
            "zplug --rollback=build"
    fi
fi
