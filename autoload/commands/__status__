#!/usr/bin/env zsh
# Description:
#   Check if the remote repositories are up to date

local    is_parallel=""
local    is_releases=false is_select=false
local    state arg filter repo
local -A repo_pids proc_states status_codes repo_dir
local -A tags
local -F SECONDS=0
local -a repos
local -i queue_max=$ZPLUG_THREADS
local -i spinner_idx

while (( $# > 0 ))
do
    arg="$1"
    case "$arg" in
        --select)
            is_select=true
            ;;
        -*|--*)
            __zplug::core::options::unknown "$arg"
            return $status
            ;;
        "")
            # Invalid
            return 1
            ;;
        */*)
            repos+=( "${arg:gs:@::}" )
            ;;
        *)
            return 1
            ;;
    esac
    shift
done

if $is_select; then
    __zplug::utils::shell::search_commands \
        "$ZPLUG_FILTER" \
        | read filter
    if [[ -z $filter ]]; then
        __zplug::io::print::f \
            --die \
            --zplug \
            --error \
            --func \
            "There is no available filter in ZPLUG_FILTER\n"
        return 1
    fi
    repos=( ${(@f)"$(echo "${(Fk)zplugs[@]}" | eval "$filter")"} )

    # Cace of type Ctrl-C
    if (( $#repos == 0 )); then
        return 0
    fi
fi

if (( $#repos == 0 )); then
    repos=( "${(k)zplugs[@]:gs:@::}" )
fi

for repo in "${repos[@]}"
do
    if ! __zplug::base::base::zpluged "$repo"; then
        __zplug::io::print::f \
            --die \
            --zplug \
            --func \
            "$repo: no such package\n"
        return 1
    fi
done

# Check the number of arguments
if (( $#repos > 1 )); then
    is_parallel=true
fi

rm -f "$_zplug_config[status_status]"
touch "$_zplug_config[status_status]"

# Suppress outputs
setopt nonotify nomonitor
tput civis

__zplug::io::print::f \
    --zplug \
    "Start to get remote status %d plugin${is_parallel:+"s"} %s\n\n" \
    $#repos \
    "${is_parallel:+"in parallel"}"

for repo in "${repos[@]}"
do
    {
        __zplug::core::tags::parse "$repo"
        tags=( "${reply[@]}" )

        if [[ -d $tags[dir] ]]; then
            # Get package status in subprocess
            # Change directory to get the remote status
            __zplug::utils::shell::cd "$tags[dir]"

            case "$tags[from]" in
                "local")
                    status_code=$_zplug_status[status_skip_local_repo]
                    ;;
                "gh-r")
                    __zplug::utils::releases::get_state "$tags[name]" "$tags[dir]"
                    status_code=$status
                    ;;
                *)
                    __zplug::utils::git::get_state "$tags[name]" "$tags[dir]"
                    status_code=$status
                    ;;
            esac
        else
            status_code=$_zplug_status[status_repo_not_found]
        fi

        # Manage the status codes in a file
        # to lock the file in order to write asynchronously
        __zplug::job::handle::flock \
            "$_zplug_config[status_status]" \
            "repo:$repo\tstatus:$status_code"
    } &
    repo_pids[$repo]=$!
    repo_dir[$repo]="$tags[dir]"
    proc_states[$repo]="created"
    status_codes[$repo]=""

    if ( (( $#repos >= $queue_max )) && (( $#repo_pids >= $queue_max )) ) ||
        ( (( $#repos >= $queue_max )) && (( $#status_codes == $#repos )) ) ||
        ( (( $#repos < $queue_max )) && (( $#repo_pids == $#repos )) ) ; then
        repeat $(($#repo_pids + 2)); do printf "\n"; done
        #
        # Multiple progress bars
        #
        # Use printf command (not builtin) instead of __zplug::io::print::f function,
        # because this loop is run the processing by interval of 0.1 second
        # and there is a need to be called faster
        while __zplug::job::state::running "$repo_pids[@]" || (( ${(k)#proc_states[(R)running]} > 0 ))
        do
            sleep 0.1
            __zplug::utils::ansi::cursor_up $(($#repo_pids + 2)) #$(($#repos + 2))

            # Count up within _zplug_spinners index
            if (( ( spinner_idx+=1 ) > $#_zplug_spinners )); then
                spinner_idx=1
            fi

            # Processing pids
            for repo in "${(k)repo_pids[@]}"
            do
                if __zplug::job::state::running "$repo_pids[$repo]"; then
                    __zplug::job::message::fetching \
                        $_zplug_spinners[$spinner_idx] \
                        "$repo"
                    proc_states[$repo]="running"
                else
                    # Save status code for process cache
                    if [[ -z $status_codes[$repo] ]]; then
                        status_codes[$repo]="$(__zplug::job::state::get "$repo" status)"
                    fi
                    case $status_codes[$repo] in
                        $_zplug_status[status_up_to_date])
                            __zplug::job::message::up_to_date "$repo"
                            ;;
                        $_zplug_status[status_local_out_of_date])
                            __zplug::job::message::local_out_of_date "$repo"
                            ;;
                        $_zplug_status[status_not_on_any_branch])
                            __zplug::job::message::not_on_any_branch "$repo"
                            ;;
                        $_zplug_status[status_not_git_repo])
                            __zplug::job::message::not_git_repo "$repo"
                            ;;
                        $_zplug_status[status_repo_not_found])
                            __zplug::job::message::repo_not_found "$repo"
                            ;;
                        $_zplug_status[status_skip_local_repo])
                            __zplug::job::message::skip_local_repo "$repo"
                            ;;
                        *)
                            __zplug::job::message::unknown "$repo"
                            ;;
                    esac
                    proc_states[$repo]="terminated"
                fi
            done

            if __zplug::job::state::running "$repo_pids[@]"; then
                printf "\n"
                __zplug::io::print::f \
                    --zplug \
                    "Finished: %d/%d plugin%s\n" \
                    ${(k)#proc_states[(R)terminated]} \
                    $#repos \
                    ${is_parallel:+"s"}
            else
                repo_pids=()
            fi
        done
    fi
done

tput cnorm
printf "\n"
__zplug::utils::ansi::erace_current_line
__zplug::io::print::f \
    --zplug \
    "Elapsed time: %.4f sec.\n" \
    $SECONDS

if (( ${(k)#status_codes[(R)1]} == 0 )); then
    printf "$fg_bold[default] ==> All packages are up-to-date!$reset_color\n"
else
    printf "$fg_bold[red] ==> Run 'zplug update'. These packages are local out of date:$reset_color\n"
    # Listing the packages that have failed to install
    for repo in "${(k)status_codes[@]}"
    do
        if [[ $status_codes[$repo] == 1 ]]; then
            printf " - %s\n" "$repo"
        fi
    done
fi
