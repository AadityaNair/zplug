#!/bin/zsh
#              _             
#    _____ __ | |_   _  __ _ 
#   |_  / '_ \| | | | |/ _` |
#    / /| |_) | | |_| | (_| |
#   /___| .__/|_|\__,_|\__, |
#       |_|            |___/ 
#
#  zplug: zsh plugin manager
# ===========================
#
# Download zplug and put it in ~/.zplug
#
#   curl -fLo ~/.zplug/zplug --create-dirs \
#     https://raw.githubusercontent.com/b4b4r07/zplug/master/zplug
#
# Edit your .zshrc
#
: <<'EXAMPLE'
source ~/.zplug/zplug

# Make sure you use double quotes
zplug "zsh-users/zsh-syntax-highlighting"
zplug "zsh-users/zsh-substring-search"

# shell commands
zplug "holman/spark", as:cmd
# shell commands (specify export directory path using `of` specifier)
zplug "b4b4r07/http_code", as:cmd, of:bin
# shell commands (whatever language is OK; e.g., perl script)
zplug "k4rthik/git-cal", as:cmd

# binaries (from GitHub Releases)
zplug "junegunn/fzf-bin", \
    as:cmd, \
    from:gh-r, \
    file:fzf

# branch/tag
zplug "b4b4r07/enhancd", at:v1

# true or false
zplug "hchbaw/opp.zsh", if:"[ ${ZSH_VERSION%%.*} -lt 5 ]"

# Group dependencies, emoji-cli depends on jq
zplug "stedolan/jq", \
    as:cmd, \
    file:jq, \
    from:gh-r \
    | zplug "b4b4r07/emoji-cli"

# source plugins and add commands to $PATH
zplug load

EXAMPLE
#
# Then reload .zshrc and `zplug install; zplug load` to install plugins.
# Visit https://github.com/b4b4r07/zplug for more information.
#
# The MIT License (MIT)
# Copyright © 2015 Masaki Ishiyama <b4b4r07@gmail.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

# environment variable (read-only)
typeset -gr ZPLUG_NAME=zplug
typeset -gr ZPLUG_VERSION=0.1.0
typeset -gr ZPLUG_RAWURL="https://raw.githubusercontent.com/b4b4r07/zplug/master/zplug"
typeset -gr ZPLUG_URL="https://github.com/b4b4r07/zplug"

# set default value if not present
typeset -gx ZPLUG_HOME=${ZPLUG_HOME:-~/zplug/repos}
typeset -gx ZPLUG_THREADS=${ZPLUG_THREADS:-16}
typeset -gx ZPLUG_SHALLOW=${ZPLUG_SHALLOW:-true}
typeset -gx ZPLUG_PROTOCOL=${ZPLUG_PROTOCOL:-HTTPS}

# global variable
typeset -g -A zplugs

__die() {
    printf "$@\n" >&2
}

git_version() {
    echo ${${(A)"$(git --version)"}[3]//./}
}

bg_rotation_bar() {
    local current_count simbol
    for ((current_count=0; ; current_count++))
    do
        let simbol=current_count%4
        case "$simbol" in
            0) echo -ne " |\r";;
            1) echo -ne " /\r";;
            2) echo -ne " -\r";;
            3) echo -ne " \\\\\r";;
        esac
        sleep 0.05s
    done
}

__zplug::list()
{
    if (($#zplugs < 1)); then
        __die "$ZPLUG_NAME: there is no available plugins"
        return 1
    fi
    local v
    local -A B
    for v in "${(@nO)zplugs}"; do
        B+=("${(@kv)zplugs[(eR)$v]}")
    done
    command printf '%-20s  =>  %s\n' "${(@kv)B}" \
        | sed -e 's/-EMP-/""/g' \
        | perl -pe 's/^(.*)( *=>.*)$/\033[32m$1\033[m$2/g' \
        | perl -pe 's/(as|of|from|to|if|dir|file|at|do|frozen|on|commit)(:)/\033[34m$1\033[m$2/g'
}

__zplug::selfupdate()
{
    curl -fLo $ZPLUG_HOME/zplug --create-dirs $ZPLUG_RAWURL >/dev/null 2>&1
    if [[ $status -eq 0 ]]; then
        printf "\033[32mUpdated $ZPLUG_NAME ($ZPLUG_HOME/zplug)\033[m\n"
    else
        printf "\033[31mError occured (see $ZPLUG_URL)\033[m\n"
        return 1
    fi
}

__zplug::update()
{
    # Disable job control
    set +m

    # Process argments
    case "$1" in
        --self)
            __zplug::selfupdate; return $status
            ;;
    esac

    local cnt line
    cnt=0

    for line in "$@"; do
        # Run installation in subprocess
        {
            # All variables are treated as local variable
            # because of background job (subprocess)
            local -A zspec
            zspec=( ${(@f)"$(__zplug::parser "$line")"} )
            for k in ${(k)zspec}
            do
                if [[ $zspec[$k] == "-EMP-" ]]; then
                    zspec[$k]=""
                fi
            done

            # Reset timer
            typeset -F SECONDS=0

            if [[ $zspec[frozen] -eq 1 ]]; then
                command printf " \033[34m* Frozen\033[m    $line\n"
                continue
            fi

            command printf "Updating...  $line\n"
            bg_rotation_bar & bg_pid=$!
            () {
                builtin cd $zspec[dir] || builtin cd ${zspec[dir]%/*} || return 2
                if [[ $zspec[from] == "gh-r" ]]; then
                    eval 'L=$zspec[name] bash -c "$(curl -L git.io/releases)" -s os'
                else
                    git pull --quiet
                fi || return 1
            } >/dev/null 2>&1
            ret=$status

            # Kill bg_rotation_bar animation
            kill -9 $bg_pid

            case $ret in
                0)
                    command printf "\033[32mUpdated!\033[m     %-20s\t(%.2fs)\n" "$line" $SECONDS
                    ;;
                1)
                    command printf "\033[31mNot Updated\033[m  %-20s\t(%.2fs)\n" "$line" $SECONDS
                    ;;
                2)
                    sleep 1
                    command printf "\033[35mNot Found\033[m    %-20s\t(%.2fs)\n" "$line" $((SECONDS-1))
                    ;;
            esac
        } &
        # Prevent having too many subprocesses
        (( (cnt += 1) % ZPLUG_THREADS == 0 )) && wait
    done
    wait
    set -m
}

__zplug::install()
{
    local cnt line fail job
    local start end
    cnt=0
    [[ -d $ZPLUG_HOME ]] || mkdir -p "$ZPLUG_HOME"
    [[ -n $1 ]] || return 0

    # Disable job control
    set +m

    start="$(date +%s)"
    for line in "$@"; do
        # Skip installed items
        [[ -e $ZPLUG_HOME/$line ]] &&
            {
                command printf "\033[31m-\033[m \033[32m${line}\033[m: already installed\n"
                continue
            }

        # Run installation in subprocess
        {
            # All variables are treated as local variable
            # because of background job (subprocess)
            local -A zspec
            zspec=( ${(@f)"$(__zplug::parser "$line")"} )
            for k in ${(k)zspec}
            do
                if [[ $zspec[$k] == "-EMP-" ]]; then
                    zspec[$k]=""
                fi
            done

            # Reset timer
            typeset -F SECONDS=0

            command printf "Installing...  $line\n"
            bg_rotation_bar & bg_pid=$!
            builtin cd $ZPLUG_HOME >/dev/null 2>&1

            # Download
            if [[ $zspec[from] == "gh-r" ]]; then
                # from GitHub Releases
                [[ -d ${zspec[name]%/*} ]] || mkdir -p "${zspec[name]%/*}"
                builtin cd "${zspec[name]%/*}"
                eval 'L=$zspec[name] bash -c "$(curl -L git.io/releases)" -s os' >/dev/null 2>&1
                ret=${ret:-$status}

            else
                local url_format
                if [[ $ZPLUG_PROTOCOL =~ ^(HTTPS|https)$ ]]; then
                    url_format="https://git::@github.com/${line}.git"
                    if (( $(git_version) > 230 )); then
                        GIT_TERMINAL_PROMPT=0
                        url_format="https://github.com/${line}.git"
                    fi
                elif [[ $ZPLUG_PROTOCOL =~ ^(SSH|ssh)$ ]]; then
                    url_format="git@github.com:${line}.git"
                else
                    __die "\033[31m x Failed      $line\033[m (use SSH/HTTPS for cloning protocol)"
                    ret=${ret:-2}
                fi

                local shallow_clone
                if $ZPLUG_SHALLOW && [[ -z $zspec[commit] ]]; then
                    shallow_clone="--depth=1"
                fi
                # from GitHub
                [[ $ret -eq 0 ]] &&
                git clone $shallow_clone \
                    --recursive \
                    --quiet \
                    --branch $zspec[at] \
                    "$url_format" "$line" >/dev/null 2>&1
                ret=${ret:-$status}
                if [[ -n $zspec[commit] ]]; then
                    builtin cd "$line" && git checkout $zspec[commit] >/dev/null 2>&1
                fi
            fi

            # If not empty
            if [[ -n $zspec[do] ]]; then
                if [[ $ret -eq 0 ]]; then
                    # Run command
                    eval "$zspec[do]"
                fi
            fi

            # Kill bg_rotation_bar animation
            kill -9 $bg_pid

            # Whether to success or not
            if [ $ret -eq 0 ]; then
                command printf "\033[32mInstalled!\033[m     %-20s\t(%.2fs)\n" "$line" $SECONDS
            elif [ $ret -eq 1 ]; then
                command printf "\033[31mNot Installed\033[m  %-20s\t(%.2fs)\n" "$line" $SECONDS
                false
            else
                false
            fi
        } &

        # Prevent having too many subprocesses
        (( (cnt += 1) % ZPLUG_THREADS == 0 )) && wait
    done

    # Count if fail
    fail=0

    # Pauses until execution of a background process has ended
    for job in ${${(v)jobstates##*:*:}%=*}
    do
        wait $job || let "fail+=1"
    done >/dev/null 2>&1
    # Wait until all jobs known to the invoking shell have terminated
    wait
    set -m

    # Skip footer prints if noting to do
    if [[ $cnt -eq 0 ]]; then
        return 0
    fi

    # Footer prints
    if [[ $fail -eq 0 ]]; then
        command printf "\033[;1m ==> Installed all plugins to $ZPLUG_HOME, successfully!\033[m\n"
    else
        command printf "\033[31;1m ==> Installed to $ZPLUG_HOME but failed.\033[m\n"
    fi

    end="$(date +%s)"
    command printf "$ZPLUG_NAME: total time %d sec\n" $(($end - $start))

    return $fail
}

__zplug::parser()
{
    local zplug split_array
    zplug="$1"
    zplug="${zplug},${zplugs[$zplug]%,}"

    # Split by comma
    split_array=(${(s:,:)zplug})

    # Add spec variable
    # If value is empty, set -EMP- value to it
    local name as of to from if dir file at do frozen on commit
    name="${split_array[1]}"
    as=${${${(M)split_array:#as*}#*:}:-src}
    of=${${${(M)split_array:#of*}#*:}:--EMP-}
    to=${${${(M)split_array:#to*}#*:}:--EMP-}
    from=${${${(M)split_array:#from*}#*:}:--EMP-}
    if=${${${(M)split_array:#if*}#*:}:--EMP-}
    dir=${${${(M)split_array:#dir*}#*:}:--EMP-}
    file=${${${(M)split_array:#file*}#*:}:--EMP-}
    at=${${${(M)split_array:#at*}#*:}:-master}
    do=${${${(M)split_array:#do*}#*:}:--EMP-}
    frozen=${${${(M)split_array:#frozen*}#*:}:-0}
    on=${${${(M)split_array:#on*}#*:}:--EMP-}
    commit=${${${(M)split_array:#commit*}#*:}:--EMP-}

    local -A zplugs_parsed
    zplugs_parsed=(
      name    "$name"
      as      "$as"
      of      "$of"
      to      "$to"
      from    "$from"
      if      "$if"
      dir     "$dir"
      file    "$file"
      at      "$at"
      do      "$do"
      frozen  "$frozen"
      on      "$on"
      commit  "$commit"
    )

    local k
    for k in ${(k)zplugs_parsed}
    do
        echo "$k"
        echo "$zplugs_parsed[$k]"
    done
}

__zplug::load()
{
    local f files k
    local zplug
    local -A zspec

    for zplug in ${(k)zplugs}
    do
        # Set zspec
        zspec=( ${(@f)"$(__zplug::parser "$zplug")"} )
        # Replace -EMP- with ""(empty)
        for k in ${(k)zspec}
        do
            if [[ $zspec[$k] == "-EMP-" ]]; then
                zspec[$k]=""
            fi
        done

        # If not empty
        if [[ -n $zspec[if] ]]; then
            if ! eval '$zspec[if]' >/dev/null 2>&1; then
                __die "$zspec[name]: (not load)"
                continue
            fi
        fi

        if [[ -n $zspec[on] ]]; then
            if ! [[ -e $ZPLUG_HOME/$zspec[on] ]]; then
                __die "$zspec[name]: (not load)"
                continue
            fi
        fi

        # Branch cmd/src
        case $zspec[as] in
            cmd)
                files=()
                mkdir -p ${ZPLUG_HOME%/*}/bin 2>/dev/null

                # Search binary/command file
                if [[ -f $zspec[dir]/${zspec[name]#*/} ]]; then
                    files=("$zspec[dir]/${zspec[name]#*/}")
                elif [[ -f $zspec[dir]/$zspec[of] ]]; then
                    files+=("$zspec[dir]/$zspec[of]")
                elif [[ -f $zspec[dir]/$zspec[of]/${zspec[name]#*/} ]]; then
                    files+=("$zspec[dir]/$zspec[of]/${zspec[name]#*/}")
                elif [[ -f $zspec[dir] ]]; then
                    files+=("$zspec[dir]")
                fi

                # Disable job control
                set +m

                # Make symlink to $ZPLUG_HOME/bin exported in parallel
                for f in "$files[@]"
                do
                    {
                        # Support commit sha
                        # local pat
                        # pat="^($(git branch | cut -c3- | paste -s -d"|" -))$"
                        # if [[ ! $zspec[at] =~ $pat ]]; then
                        #     builtin cd $zspec[dir]
                        #     git checkout $zspec[at]
                        # fi
                        builtin cd ${ZPLUG_HOME%/*}/bin
                        ln -snf "$f" ${zspec[file]:-.}
                    } >/dev/null 2>&1 &
                done
                wait
                set -m

                # Export
                path=("${ZPLUG_HOME%/*}/bin" $path)
                typeset -gx -U path
                ;;

            src)
                # Search plugin files by pattern
                files=($(zsh -c "echo $zspec[dir]/${zspec[of]:-*.sh(N)}" 2>/dev/null))
                for f in $files
                do
                    source "$f"
                done
                ;;
        esac
    done
}

__zplug::check()
{
    local line is_verbose=false is_install=false
    local -A zspec
    local -a fail args

    fail=()
    while (( $# > 0 ))
    do
        case "$1" in
            --verbose)
                is_verbose=true
                ;;
            --install)
                is_install=true
                ;;
            *)
                args+=("$1")
        esac
        shift
    done

    for line in "$args[@]"
    do
        zspec=( ${(@f)"$(__zplug::parser "$line")"} )
        if [[ ! -e $zspec[dir] ]]; then
            fail+=("$zspec[name]")
        fi
    done

    if (( $#fail > 0 )); then
        if $is_verbose; then
            printf "- \033[31m%s\033[m: not installed\n" "${(@nO)fail}"
        fi
        if $is_install; then
            __zplug::install "${fail[@]}"
            return $status
        fi
        return 1
    else
        return 0
    fi
}

zplug() {
    local arg
    arg="$1"

    case "$arg" in
        help)
            return 0
            ;;

        version)
            echo "$ZPLUG_VERSION"
            return 0
            ;;

        check)
            shift
            __zplug::check "$@" ${(k)zplugs}
            return $status
            ;;

        update)
            shift
            __zplug::update "$@" ${(k)zplugs}
            return $status
            ;;

        list)
            __zplug::list
            return $status
            ;;

        install)
            shift
            __zplug::install ${@:-${(k)zplugs}}
            return $status
            ;;

        load)
            __zplug::load
            return $status
            ;;

        "")
            return 1
            ;;

        *)
            shift
            arg="${arg%,}"
            if [[ $arg =~ ^[A-Za-z0-9._-]+/[A-Za-z0-9._-]+$ ]]; then
                local cnt=0 dep stdin
                local -a task args dep_args
                task=("$arg")

                if [[ -p /dev/stdin ]]; then
                    stdin="$(cat <&0)"
                    dep="${stdin%%:*}"
                    task=("$dep" "$arg")
                    dep_args=("${stdin#*:}")
                    let "cnt++"
                fi
                if [[ -p /dev/stdout ]]; then
                    echo "$arg:$@"
                    let "cnt++"
                fi
                if (( cnt >= 2 )); then
                    __die "$dep: not install (zplug 3 pipeline)"
                    return 1
                fi

                local i specifier
                for arg in "${task[@]}"
                do
                    if [[ $arg == $dep ]]; then
                        args=("${(s:, :)dep_args}")
                    else
                        args=("$@")
                    fi

                    for i in $args
                    do
                        case "${i%%:*}" in
                            as|of|from|to|if|dir|file|at|do|frozen|on|commit)
                                specifier="${specifier}${i%,},"
                                ;;
                            *)
                                echo "$i: invalid specifier"
                                return 1
                                ;;
                        esac
                    done

                    specifier="${specifier%,}"
                    # Add to $zplugs(AA; key:"user/repo" => value:"specifier:value")
                    zplugs+=("$arg" "${specifier:-}")
                    # Add dir specifier to $zplugs
                    zplugs[$arg]+="${zplugs[$arg]:+,}dir:$ZPLUG_HOME/$arg"
                    if [[ $arg != $dep && -n $dep ]]; then
                        zplugs[$arg]+="${zplugs[$arg]:+,}on:$dep"
                    fi
                    specifier=""
                done

                # Initialize all specifiers
                # local zplug
                # for zplug in ${(k)zplugs}
                # do
                #     zplugs[$zplug]="$(
                #     () {
                #         local -A zspec
                #         local k cnt=0
                #         zspec=( ${(@f)"$(__zplug::parser "$zplug")"} )
                #         for k in ${(k)zspec}
                #         do
                #             printf "$k:$zspec[$k],"
                #         done
                #         echo
                #     } | sed -e 's/,$//'
                #     )"
                # done
            else
                __die "$arg: no such command"
                return 1
            fi
            ;;
    esac
}

if (( ! $+functions[compdef] )); then
    autoload -Uz compinit
    compinit
fi
_zplug () {
    compadd         \
        install     \
        update      \
        list        \
        load        \
        check       \
        version     \
        help
}
compdef _zplug zplug

# __END__ {{{1
# vim:fdm=marker fdc=3 ft=zsh ts=4 sw=4 sts=4:
